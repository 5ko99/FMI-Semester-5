;accumulate function
(define (accumulate op term init a next b)  
  (define (loop i)
      (if (<= i b)
          (op (term i) (loop (next i)) )
          init
  ))
  (loop a)
)

(define (accumulate1 op term init a next b)  
  (define (loop i)
      (if (>= i b)
          (op (term i) (loop (next i)) )
          init
  ))
  (loop a)
)
;printing simple functions
(define (dash x y) (display #\─))
(define (vert x y) (display #\│)
(display #\space))
(define (vertAfter x y) (display #\space)
(display #\│))
;closure of accumulate
(define (print f a b)
  (define (id x) x)
  (define (1+ x) (+ x 1))
  (accumulate f id 0 a 1+ b))

(define (alt n)
  (define (a k)
         (print vert 1 (- n k))
         (display #\┌)
         (print dash 1 (- (* 4 k) 3))
         (display #\┐)
         (print vertAfter 1 (- n k))
         (display #\newline)
         k)
  (define (b k junk)
         (print vert 1 (- n k))
         (display #\└)
         (print dash 1 (- (* 4 k) 3))
         (display #\┘)
         (print vertAfter 1 (- n k))
         (display #\newline))
  (define (1- x) (- x 1))
    
  (accumulate1 b a (display "") n 1- 1))

(define (solution n)
  (define (helper k)
    (if (> k 0)
        (begin
         (print vert 1 (- n k))
         (display #\┌)
         (print dash 1 (- (* 4 k) 3))
         (display #\┐)
         (print vertAfter 1 (- n k))
         (display #\newline)
         (helper (- k 1))
         (print vert 1 (- n k))
         (display #\└)
         (print dash 1 (- (* 4 k) 3))
         (display #\┘)
         (print vertAfter 1 (- n k))
         (display #\newline))
        (display "")))
  (helper n))

(define (squares n)
  (solution n))